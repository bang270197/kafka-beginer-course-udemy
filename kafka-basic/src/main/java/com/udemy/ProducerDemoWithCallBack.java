package com.udemy;import org.apache.kafka.clients.producer.*;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.Properties;public class ProducerDemoWithCallBack {    public static final Logger logger = LoggerFactory.getLogger(ProducerDemoWithCallBack.class.getName());    public static void main(String[] args) {        Properties props = new Properties();        props.put("bootstrap.servers", "127.0.0.1:9092");  // Kafka broker        props.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");        props.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");        //Dòng này thiết lập thuộc tính batch.size cho Kafka Producer với giá trị 400 byte.        // Thuộc tính này quy định kích thước tối đa của một lô dữ liệu mà Producer sẽ gửi đến Kafka.        //batch.size là kích thước tối đa của một lô thông điệp mà Kafka Producer sẽ thu thập trước khi gửi chúng đến broker. Producer sẽ cố gắng thu thập nhiều thông điệp nhỏ và gửi chúng cùng nhau trong một lô để tối ưu hóa việc sử dụng tài nguyên mạng và tăng hiệu suất.        //Nếu lô đã đạt đến kích thước giới hạn được định nghĩa trong batch.size, Kafka Producer sẽ gửi ngay lập tức.        //Nếu lô không đạt tới giới hạn batch.size nhưng đã hết thời gian chờ (cấu hình qua linger.ms), Kafka Producer cũng sẽ gửi lô dữ liệu dù chưa đầy.//        Lợi ích của việc điều chỉnh batch.size://        Hiệu suất tốt hơn: Tăng kích thước batch có thể giúp cải thiện hiệu suất, vì ít request hơn sẽ được gửi đến broker, giảm chi phí về tài nguyên mạng và CPU.//        Độ trễ thấp hơn: Nếu kích thước batch quá lớn, producer có thể sẽ phải đợi lâu hơn để lô đầy, điều này có thể tăng độ trễ. Việc điều chỉnh kích thước batch cần phù hợp với ứng dụng của bạn để cân bằng giữa hiệu suất và độ trễ.        //props.setProperty("batch.size", "400"); // không khuyến nghị, nên để mặc định        //phân phối thông điệp đồng đều giữa các partition để tối ưu hóa tài nguyên và tránh trường hợp chỉ một partition bị quá tải.        //props.setProperty("partitioner.class", RoundRobinPartitioner.class.getName());        KafkaProducer<String, String> producer = new KafkaProducer<>(props);        for (int j = 0; j < 10; j++) {            for (int i = 0; i < 30; i++) {                producer.send(new ProducerRecord<>("TOPIC-1", "name", "hello world " + i), new Callback() {                    @Override                    public void onCompletion(RecordMetadata recordMetadata, Exception e) {                        if (e == null){                            logger.info("Received new metadata \n"+                                            "Topic: {} \n"+                                            "Partition: {} \n"+                                            "Offset: {} \n"+                                            "TimeStamp: {}", recordMetadata.topic(),                                    recordMetadata.partition(),                                    recordMetadata.offset(),                                    recordMetadata.timestamp()                            );                        } else {                            logger.error("Error while sending message", e);                        }                    }                });            }            try {                Thread.sleep(500);            } catch (InterruptedException e) {                e.printStackTrace();            }        }        producer.flush();        producer.close();    }}